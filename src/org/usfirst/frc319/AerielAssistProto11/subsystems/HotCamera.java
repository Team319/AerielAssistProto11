// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package org.usfirst.frc319.AerielAssistProto11.subsystems;
import edu.wpi.first.wpilibj.Relay;
import edu.wpi.first.wpilibj.camera.AxisCamera;
import edu.wpi.first.wpilibj.camera.AxisCameraException;
import org.usfirst.frc319.AerielAssistProto11.RobotMap;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.image.BinaryImage;
import edu.wpi.first.wpilibj.image.ColorImage;
import edu.wpi.first.wpilibj.image.CriteriaCollection;
import edu.wpi.first.wpilibj.image.NIVision;
import edu.wpi.first.wpilibj.image.NIVisionException;
import edu.wpi.first.wpilibj.image.ParticleAnalysisReport;
import org.usfirst.frc319.AerielAssistProto11.Robot;
import org.usfirst.frc319.AerielAssistProto11.commands.CameraSleep;
/**
 *
 */
public class HotCamera extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    Relay hotRelay = RobotMap.hotRelay;
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    //Camera constants used for distance calculation
    final int Y_IMAGE_RES = 480;		//X Image resolution in pixels, should be 120, 240 or 480
    final double VIEW_ANGLE = 49;		//Axis M1013
    //final double VIEW_ANGLE = 41.7;		//Axis 206 camera
    //final double VIEW_ANGLE = 37.4;  //Axis M1011 camera
    final double PI = 3.141592653;
    //Score limits used for target identification
    final int  RECTANGULARITY_LIMIT = 40;
    final int ASPECT_RATIO_LIMIT = 55;
    //Score limits used for hot target determination
    final int TAPE_WIDTH_LIMIT = 50;
    final int  VERTICAL_SCORE_LIMIT = 50;
    final int LR_SCORE_LIMIT = 50;
    //Minimum area of particles to be considered
    final int AREA_MINIMUM = 200;
    //Maximum number of particles to process
    final int MAX_PARTICLES = 5;
    
    AxisCamera camera;          // the axis camera object (connected to the switch)
    CriteriaCollection cc;      // the criteria for doing the particle filter operation
    
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new CameraSleep());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    public void initialize() {
        camera = AxisCamera.getInstance();  // get an instance of the camera
        cc = new CriteriaCollection();      // create the criteria for the particle filter
        //cc.addCriteria(NIVision.MeasurementType.IMAQ_MT_AREA, AREA_MINIMUM, 65535, false);
        cc.addCriteria(NIVision.MeasurementType.IMAQ_MT_BOUNDING_RECT_WIDTH, 8, 65535, false);
    
    }
       
    public boolean isHot(){
        //initialize();
        camera.freshImage();
        
        
        boolean hot = false;
        try {
                /**
                 * Do the image capture with the camera and apply the algorithm described above. This
                 * sample will either get images from the camera or from an image file stored in the top
                 * level directory in the flash memory on the cRIO. The file name in this case is "testImage.jpg"
                 * 
                 */
                //ColorImage image = camera.getImage();     // comment if using stored images
                ColorImage image;                           // next 2 lines read image from flash on cRIO
                
                
                
                
                
                //image = new RGBImage("/testImage.jpg");		// get the sample image from the cRIO flash
                image = camera.getImage();
                
                int redLow = 0;//0
                int redHigh = 70;//10;
                int greenLow = 0;//0
                int greenHigh = 35;//10;
                int blueLow = 45;//50
                int blueHigh = 90;//110
                
                BinaryImage thresholdImage = image.thresholdRGB(redLow,redHigh,greenLow,greenHigh,blueLow,blueHigh);//image.thresholdHSV(105, 137, 230, 255, 133, 183);   // keep only green objects
                //thresholdImage.write("/threshold.bmp");
                BinaryImage filteredImage = thresholdImage.particleFilter(cc);           // filter out small particles
                //filteredImage.write("/filteredImage.bmp");
                
                //iterate through each particle and score to see if it is a target
                //Scores scores[] = new Scores[filteredImage.getNumberParticles()];
                //horizontalTargetCount = verticalTargetCount = 0;
                
              //  System.out.println("particle count: " + filteredImage.getNumberParticles());
                
                if(filteredImage.getNumberParticles() > 0)
                {
                    int targetWidth = 0;
                    
                    for (int i = 0; i < MAX_PARTICLES && i < filteredImage.getNumberParticles(); i++) {
			ParticleAnalysisReport report = filteredImage.getParticleAnalysisReport(i);
                        double widthRatio = report.boundingRectWidth / report.boundingRectHeight;
                        if(widthRatio > 3 && widthRatio < 12){
                            targetWidth = report.boundingRectWidth;
                        }
                        /**
                        if (report.boundingRectWidth > targetWidth){
                            targetWidth = report.boundingRectWidth;
                        }
                        * **/
                 //      System.out.println("particle height: " + report.boundingRectHeight);
                     //   System.out.println("particle width: " + report.boundingRectWidth);
                //        System.out.println("particle size: " + report.particleArea);
                       // System.out.println("Target Width: " + targetWidth);
                        
                    }
                    int minWidth = 30;
                    
                    hot = targetWidth > minWidth;
                   // System.out.println("hot");
                     
                }
                /**
                 * all images in Java must be freed after they are used since they are allocated out
                 * of C data structures. Not calling free() will cause the memory to accumulate over
                 * each pass of this loop.
                 */
                filteredImage.free();
                thresholdImage.free();
                image.free();
              
                return hot;
                
                    
        
                
//            } catch (AxisCameraException ex) {        // this is needed if the camera.getImage() is called
//                ex.printStackTrace();
            } catch (NIVisionException ex) {
                System.out.println(ex.getMessage());
                ex.printStackTrace();
            }
            catch (AxisCameraException ex) {
                System.out.println(ex.getMessage());
                ex.printStackTrace();
            }
        return false;
         
    }
    
    public void hotLightOn(){
        Robot.hotCamera.hotRelay.set(Relay.Value.kForward);
    }
    
    public void hotLightOff(){
        Robot.hotCamera.hotRelay.set(Relay.Value.kOff);
    }
    
   /* public double getHeight() throws Exception{
        //initialize();
        camera.freshImage();
        
        
        boolean hot = false;
        try {
                /**
                 * Do the image capture with the camera and apply the algorithm described above. This
                 * sample will either get images from the camera or from an image file stored in the top
                 * level directory in the flash memory on the cRIO. The file name in this case is "testImage.jpg"
                 * 
                 */
                //ColorImage image = camera.getImage();     // comment if using stored images
            /*    ColorImage image;                           // next 2 lines read image from flash on cRIO
                
                
                
                
                
                //image = new RGBImage("/testImage.jpg");		// get the sample image from the cRIO flash
                image = camera.getImage();
                
                int redLow = 0;//0
                int redHigh = 10;//100;
                int greenLow = 0;//110
                int greenHigh = 10;//255;
                int blueLow = 50;//235
                int blueHigh = 110;//255
                
                BinaryImage thresholdImage = image.thresholdRGB(redLow,redHigh,greenLow,greenHigh,blueLow,blueHigh);//image.thresholdHSV(105, 137, 230, 255, 133, 183);   // keep only green objects
                //thresholdImage.write("/threshold.bmp");
                BinaryImage filteredImage = thresholdImage.particleFilter(cc);           // filter out small particles
                //filteredImage.write("/filteredImage.bmp");
                
                //iterate through each particle and score to see if it is a target
                //Scores scores[] = new Scores[filteredImage.getNumberParticles()];
                //horizontalTargetCount = verticalTargetCount = 0;
                
                System.out.println("particle count: " + filteredImage.getNumberParticles());
                
                double maxHeight = 0;
                if(filter.edImage.getNumberParticles() > 0)
                {
                    int targetWidth = 0;
                    
                    for (int i = 0; i < MAX_PARTICLES && i < filteredImage.getNumberParticles(); i++) {
			ParticleAnalysisReport report = filteredImage.getParticleAnalysisReport(i);
                        double widthRatio = report.boundingRectWidth / report.boundingRectHeight;
                        if(widthRatio > 3 && widthRatio < 12){
                            targetWidth = report.boundingRectWidth;
                        }
                        if(report.boundingRectHeight > maxHeight){
                            maxHeight = report.boundingRectHeight;
                        }
                        /**
                        if (report.boundingRectWidth > targetWidth){
                            targetWidth = report.boundingRectWidth;
                        }
                        * **/
                    /*    System.out.println("particle height: " + report.boundingRectHeight);
                        System.out.println("particle width: " + report.boundingRectWidth);
                        System.out.println("particle size: " + report.particleArea);
                    }
                    int minWidth = 30;
                    
                    hot = targetWidth > minWidth;
                     
                }
                /**
                 * all images in Java must be freed after they are used since they are allocated out
                 * of C data structures. Not calling free() will cause the memory to accumulate over
                 * each pass of this loop.
                 */
              /*  filteredImage.free();
                thresholdImage.free();
                image.free();
             
                return maxHeight;
//            } catch (AxisCameraException ex) {        // this is needed if the camera.getImage() is called
//                ex.printStackTrace();
            } catch (NIVisionException ex) {
                System.out.println(ex.getMessage());
                ex.printStackTrace();
            }
            catch (AxisCameraException ex) {
                System.out.println(ex.getMessage());
                ex.printStackTrace();
            }
        throw new Exception("There was an issue finding the target.");
    } */
    
}
